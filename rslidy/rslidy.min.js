/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = __webpack_require__(1);
const settings_1 = __webpack_require__(2);
const statusbar_1 = __webpack_require__(3);
const overview_1 = __webpack_require__(4);
const content_1 = __webpack_require__(5);
const image_viewer_1 = __webpack_require__(7);
// Implements the core functionality.
class Rslidy {
    // Methods
    //
    // Init methods
    //
    // ---
    // Description: Constructor.
    // ---
    constructor() {
        this.url_delimiter = '#';
        this.os = "";
        this.num_slides = 0;
        this.url_delimiter = "#";
        this.shift_pressed = false;
        this.ctrl_pressed = false;
        this.alt_pressed = false;
        this.meta_pressed = false;
        this.full_overview = true;
        this.low_light_mode = false;
        this.timer_enabled = false;
        this.timer_time = 0;
        this.timer_thread = null;
        // Key codes (platform-specific settings in rslidy.platformSpecificSettings() if needed)
        this.key_enter = 13;
        this.key_space = 32;
        this.key_pg_up = 33;
        this.key_pg_down = 34;
        this.key_end = 35;
        this.key_home = 36;
        this.key_left = 37;
        this.key_up = 38;
        this.key_right = 39;
        this.key_down = 40;
        this.key_n = 78;
        this.key_t = 84;
        // Custom settings
        this.presentation_time = 0; // Presentation time in seconds. 0 to disable (hides timer).
        this.close_menu_on_selection = true;
        this.close_navigation_on_selection = true;
        this.start_in_low_light_mode = false;
        this.block_slide_text_selection = false;
        this.svg_fix_on_ios = false;
        this.custom_aspect_ratio = 0; // Use of custom aspect ratio for slides. Possible values are e.g. 4/3 or 16/9. 0 disables it and makes it calculate dynamically.
        this.custom_width = 800; // Used when custom_aspect_ratio is set to a value greater than zero.
        this.overview_slide_zoom = 1.2;
        this.doubletap_delay = 200; // Double tap delay in ms
        this.min_slide_zoom = 0.2; // in em
        this.max_slide_zoom = 3.0; // in em
        this.zoom_step = 0.2; // in em
        this.swipe_max_duration = 400; // maximum duration of swipe in ms
        this.swipe_threshold = 60; // swipe distance
        this.swipe_y_limiter = 1.0; // how many times the x distance should be greater than the y distance (1.0 means x has to be > y, 2.0 means x has to be > 2 * y, 0.0 means disabled)
        this.tilt_sensitivity = 3.0; // Tilt sensitivity, higher sensitivity = less tilt required
        this.shake_sensitivity = 1.0; // Shake sensitivity, higher sensitivity = less shake required
        this.tap_last = 0;
        this.start_x = 0;
        this.start_y = 0;
        this.delta_x = 0;
        this.delta_y = 0;
        this.tilt_value_old = 0;
        this.motion_last = 0;
        this.motion_break = 500; // Minimum interval between movement gestures
        this.help_text = "Welcome to rslidy!\n\n" +
            "rslidy transforms HTML pages into presentation slides. Its usage is very similar to common presentation software.\n\n" +
            "• Use the buttons LEFT and RIGHT to navigate through the slide show. On devices with a touchscreen, it's possible to use swipe gestures.\n\n" +
            "• All available slides and a table of contents can be shown on the left side by clicking the corresponding buttons in the status bar on the bottom of the page.\n\n" +
            "• Settings for gestures and the night mode can be changed by clicking the Menu button in the status bar.\n\n" +
            "• When using mobile device, Shake and Tilt gestures are enabled by default. These can be disabled in the menu. Tilting helps navigating, while shaking resets the presentation to the first slide.\n\n" +
            "• If available, speaker notes can be toggled by pressing N or by double-tapping on touch devices.\n\n" +
            "• If enabled, the timer can be started/paused by pressing T or by clicking the timer in the status bar below.\n\n" +
            "Other settings like the aspect ratio of the slides and the zoom level of the thumbnails can be changed in the rslidy.js file.";
    }
    // ---
    // Description: Handles the initialization of rslidy, e.g. setting up the menus.
    // ---
    init() {
        // Set up utils
        this.utils = new utils_1.Utils();
        // Set up member variables
        this.os = window.navigator.platform;
        this.num_slides = document.querySelectorAll('.slide').length;
        // Call start-up methods
        // Wrap content-section element around body and add slive nav button
        const body_old = document.body.innerHTML;
        const slides_old = document.querySelectorAll(".slide");
        document.body.innerHTML = `<div id="new-body"></div>`;
        const newBody = document.body.querySelector('#new-body');
        // make the content visible after content has been restyled, but before slide overview generation
        document.body.style.display = 'block';
        this.toc = new overview_1.OverviewComponent(newBody, slides_old, overview_1.OverviewType.TableOfContents);
        this.overview = new overview_1.OverviewComponent(newBody, slides_old, overview_1.OverviewType.SlideOverview);
        this.content = new content_1.ContentComponent(newBody, body_old);
        this.imageViewer = new image_viewer_1.ImageViewerComponent(newBody);
        this.utils.prependHtmlString(document.body, '<div id="speakernotes-overlay"></div>');
        this.statusbar = new statusbar_1.StatusbarComponent(document.body, {});
        this.settings = new settings_1.SettingsComponent(document.body, {});
        this.addListeners();
        // Platform specific settings
        this.platformSpecificSettings();
        // Adjust SVG replacements
        this.adjustSVGReplacementsWidth();
        // Initialize the timer
        this.initTimer();
        this.onHashchange();
        console.log('rslidy into DOM injected ');
        if (window.oninjected)
            window.oninjected();
    }
    // ---
    // Description: Adds event listeners like left/right keys.
    // ---
    addListeners() {
        // Key listeners    
        window.onkeydown = e => this.keyPressed(e, 0);
        window.onkeyup = e => this.keyPressed(e, 1);
        var links = document.getElementsByTagName('a');
        for (var i = 0; i < links.length; i++) {
            links[i].addEventListener('mouseup', function (e) { e.stopPropagation(); }.bind(this));
        }
        // Window listeners
        window.addEventListener('hashchange', function () { this.onHashchange(); }.bind(this));
        // Allow simple touch events on speaker notes overlay (for double tap to hide)
        var speaker_notes_overlay = document.getElementById("speakernotes-overlay");
        speaker_notes_overlay.addEventListener('touchstart', e => this.content.onTouchstart(e));
        //content_section.addEventListener('touchmove', function (e) { e.stopPropagation(); }.bind(this));
        //document.addEventListener("touchmove", function (e) { e.preventDefault(); }.bind(this)); // Disables all scrolling!
        // Window listeners
        window.onresize = function (e) {
            this.overview.adjustOverviewPanel();
            this.adjustSVGReplacementsWidth();
        }.bind(this);
        // Device listeners used for TILT and SHAKE
        if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', function (e) { this.onDeviceOrientation(e); }.bind(this));
        }
        if (window.DeviceMotionEvent) {
            window.addEventListener('devicemotion', function (e) { this.onDeviceMotion(e); }.bind(this));
        }
        // Set motion break if device changes from PORTRAIT to LANDSCAPE or vice versa (prevent unintended slide navigation)
        window.addEventListener("orientationchange", function (e) { this.motion_last = (new Date).getTime(); }.bind(this));
    }
    // ---
    // Description: Initializes the timer.
    // ---
    initTimer() {
        // Initialize the timer or hide it if this.presentation_time <= 0
        var timer = document.getElementById("timer");
        // Hide timer or set time
        if (this.presentation_time <= 0)
            timer.classList.add("hidden");
        else {
            var minutes = Math.floor(this.presentation_time / 60);
            var seconds = this.presentation_time % 60;
            timer.innerHTML = this.utils.toTwoDigits(minutes) + ":" + this.utils.toTwoDigits(seconds);
            this.timer_time = this.presentation_time;
        }
    }
    // ---
    // Description: Toggles the timer. Works only if this.presentation_time > 0.
    // ---
    toggleTimer() {
        // Return if this.presentation_time <= 0
        if (this.presentation_time <= 0)
            return;
        // Reset and return if this.timer_time <= 0
        if (this.timer_time <= 0) {
            this.initTimer();
            return;
        }
        if (this.timer_enabled == false) {
            // Run
            this.timer_thread = setInterval(function () {
                // Break out if this.presentation_time is <= 0
                if (this.timer_time <= 0) {
                    clearInterval(this.timer_thread);
                    this.timer_enabled = false;
                    return;
                }
                this.timer_time -= 1;
                var timer = document.getElementById("timer");
                var minutes = Math.floor(this.timer_time / 60);
                var seconds = this.timer_time % 60;
                timer.innerHTML = this.utils.toTwoDigits(minutes) + ":" + this.utils.toTwoDigits(seconds);
            }.bind(this), 1000);
            this.timer_enabled = true;
        }
        else {
            // Stop
            clearInterval(this.timer_thread);
            this.timer_enabled = false;
        }
    }
    // ---
    // Description: Performs platform-specific settings.
    // ---
    platformSpecificSettings() {
        // Settings
        this.utils.debug("Searching settings for platform: " + this.os);
        switch (this.os) {
            case ("Win16"):
                // ...
                break;
            case ("Win32"):
                // ...
                break;
            case ("MacIntel"):
                // ...
                break;
            case ("iPhone"):
                if (this.svg_fix_on_ios == true)
                    this.changeSVGTags();
                break;
            case ("iPad"):
                if (this.svg_fix_on_ios == true)
                    this.changeSVGTags();
                break;
            case ("iPod"):
                if (this.svg_fix_on_ios == true)
                    this.changeSVGTags();
                break;
            default:
                this.utils.debug("Unknown platform!");
        }
    }
    // ---
    // Description: Changes the SVG img-tags to make them work on iOS.
    // ---
    changeSVGTags() {
        // Variables
        var items = document.querySelectorAll('.svg');
        // Change the tags
        for (var i = 0; i < items.length; i++) {
            // Add new class to outer link
            var outer_link = items[i].parentElement;
            if (outer_link != null)
                outer_link.classList.add("svg-link");
            var item_new = '<object class="svg svg-replacement" data="' + items[i].getAttribute("src") + '" type="image/svg+xml"></object>';
            items[i].outerHTML = item_new;
        }
    }
    // ---
    // Description: Adjusts the width of replaced SVG images.
    // ---
    adjustSVGReplacementsWidth() {
        // Get items
        var svg_replacements = document.getElementsByClassName("svg-replacement");
        var browser_width = window.innerWidth;
        for (var i = 0; i < svg_replacements.length; i++) {
            // Reset width
            svg_replacements[i].style.width = "auto";
            // Try to set max height
            svg_replacements[i].style.height = "20em";
            if (svg_replacements[i].clientWidth + svg_replacements[i].getBoundingClientRect().left > browser_width) {
                // Unset max height and set width instead if browser window is too small
                svg_replacements[i].style.height = "auto";
                svg_replacements[i].style.width = (browser_width - svg_replacements[i].getBoundingClientRect().left) + "px";
            }
        }
    }
    //
    // Key/Mouse event methods and listeners
    //
    // ---
    // Description: Called whenever a key is pressed.
    // e: Event.
    // mode: Specifies the mode (0 for down, 1 for up).
    // ---
    keyPressed(e, mode) {
        var key = e.keyCode ? e.keyCode : e.which;
        // Modifier keys (CTRL, SHIFT, ALT, META (WIN on Windows, CMD on Mac))
        this.ctrl_pressed = e.ctrlKey;
        this.shift_pressed = e.shiftKey;
        this.alt_pressed = e.altKey;
        this.meta_pressed = e.metaKey;
        // Normal key codes
        if (mode == 0) {
            switch (key) {
                case (this.key_space):
                    this.content.navNext();
                    break;
                case (this.key_pg_up):
                    this.content.navPrevious();
                    break;
                case (this.key_pg_down):
                    this.content.navNext();
                    break;
                case (this.key_end):
                    this.content.showSlide(this.num_slides - 1);
                    break;
                case (this.key_home):
                    this.content.showSlide(0);
                    break;
                case (this.key_left):
                    this.content.navPrevious();
                    break;
                case (this.key_up):
                    this.content.navPrevious();
                    break;
                case (this.key_right):
                    this.content.navNext();
                    break;
                case (this.key_down):
                    this.content.navNext();
                    break;
                case (this.key_n):
                    this.toggleSpeakerNotes(null, false);
                    break;
                case (this.key_t):
                    this.toggleTimer();
                    break;
                default:
                    this.utils.debug("Unknown key event (mode = " + mode + "): " + key);
            }
        }
    }
    // ---
    // Description: Called whenever a key in the slide input text box was pressed.
    // e: The event.
    // ---
    slideInputKeyPressed(e) {
        var key = e.keyCode ? e.keyCode : e.which;
        var slide_input = document.getElementById("slide-input");
        var value = slide_input.value;
        if (key == this.key_enter) {
            var is_number = /^[0-9]+$/.test(value);
            if (is_number == true)
                this.content.showSlide(this.utils.toInt(value) - 1);
            else
                slide_input.value = (this.content.getCurrentSlideIndex() + 1);
            // Take away focus
            slide_input.blur();
        }
    }
    // ---
    // Description: Called whenever the night mode button is clicked.
    // ---
    toggleLowLightMode() {
        // Vars
        var class_color_invert = "color-invert";
        var class_low_light_mode = "night-mode";
        // Invert everything
        var htmls = document.getElementsByTagName("html");
        this.utils.switchElementsClass(htmls, class_color_invert);
        // Apply invert again to elements which should stay the same (e.g. images)
        var imgs = document.getElementsByTagName("img");
        this.utils.switchElementsClass(imgs, class_color_invert);
        //var figures: any = document.getElementsByTagName("figure");
        //this.utils.switchElementsClass(figures, class_color_invert);
        //var figcaptions: any = document.getElementsByTagName("figcaption");
        //this.utils.switchElementsClass(figcaptions, class_color_invert);
        var svg_replacements = document.getElementsByClassName("svg-replacement");
        this.utils.switchElementsClass(svg_replacements, class_color_invert);
        // Add custom classes to h1, h2, h3, p, span, li, ul, ol, pre and a
        var h1s = document.getElementsByTagName("h1");
        this.utils.switchElementsClass(h1s, class_low_light_mode);
        this.utils.invertElementsColor(h1s, this.low_light_mode);
        var h2s = document.getElementsByTagName("h2");
        this.utils.switchElementsClass(h2s, class_low_light_mode);
        this.utils.invertElementsColor(h2s, this.low_light_mode);
        var h3s = document.getElementsByTagName("h3");
        this.utils.switchElementsClass(h3s, class_low_light_mode);
        this.utils.invertElementsColor(h3s, this.low_light_mode);
        var ps = document.getElementsByTagName("p");
        this.utils.switchElementsClass(ps, class_low_light_mode);
        this.utils.invertElementsColor(ps, this.low_light_mode);
        var lis = document.getElementsByTagName("li");
        this.utils.switchElementsClass(lis, class_low_light_mode);
        this.utils.invertElementsColor(lis, this.low_light_mode);
        var uls = document.getElementsByTagName("ul");
        this.utils.switchElementsClass(uls, class_low_light_mode);
        this.utils.invertElementsColor(uls, this.low_light_mode);
        var ols = document.getElementsByTagName("ol");
        this.utils.switchElementsClass(ols, class_low_light_mode);
        this.utils.invertElementsColor(ols, this.low_light_mode);
        var pres = document.getElementsByTagName("pre");
        this.utils.switchElementsClass(pres, class_low_light_mode);
        this.utils.invertElementsColor(pres, this.low_light_mode);
        var as = document.getElementsByTagName("a");
        this.utils.switchElementsClass(as, class_low_light_mode);
        this.utils.invertElementsColor(as, this.low_light_mode);
        this.low_light_mode = !(this.low_light_mode);
    }
    // ---
    // Description: Called whenever the address field content changes.
    // ---
    onHashchange() {
        var displayed = window.location.href.split(this.url_delimiter)[1];
        var slide_index;
        if (displayed == undefined) {
            slide_index = -1;
        }
        else {
            slide_index = displayed - 1;
        }
        this.content.showSlide(slide_index);
    }
    // ---
    // Description: Called whenever the orientation of a device changes.
    // e: Event.
    // ---
    onDeviceOrientation(e) {
        // Init if event was fired and necessary
        var checkbox_tilt = document.getElementById("checkbox-tilt");
        if (checkbox_tilt.disabled == true) {
            checkbox_tilt.disabled = false;
            checkbox_tilt.checked = true;
        }
        // Return if not activated
        if (checkbox_tilt.checked == false)
            return;
        // Store values
        var value_new = 0;
        if (window.innerHeight > window.innerWidth) {
            // Portrait mode
            value_new = Math.round(e.gamma);
        }
        else {
            // Landscape mode
            value_new = Math.round(e.beta);
        }
        var value_old = this.tilt_value_old;
        //var tilt_straight = e.beta;
        //var tilt_rot = e.alpha;
        var motion_now = (new Date).getTime();
        var motion_interval = Math.abs(motion_now - this.motion_last);
        var tilt_difference = value_new - this.tilt_value_old;
        var tilt_difference_threshold = 20.0 / this.tilt_sensitivity;
        this.shift_pressed = true;
        if (tilt_difference > tilt_difference_threshold && motion_interval > this.motion_break) {
            this.content.navNext();
            this.motion_last = motion_now;
        }
        else if (tilt_difference < -(tilt_difference_threshold) && motion_interval > this.motion_break) {
            this.content.navPrevious();
            this.motion_last = motion_now;
        }
        this.shift_pressed = false;
        // Set old value
        this.tilt_value_old = value_new;
    }
    // ---
    // Description: Called whenever the movement of the device changes (acceleration).
    // e: Event.
    // ---
    onDeviceMotion(e) {
        // Init if event was fired and necessary
        var checkbox_shake = document.getElementById("checkbox-shake");
        if (checkbox_shake.disabled == true) {
            checkbox_shake.disabled = false;
            checkbox_shake.checked = true;
        }
        // Return if not activated
        if (checkbox_shake.checked == false)
            return;
        // Store values
        var acc_x = e.acceleration.x;
        var acc_y = e.acceleration.y;
        var acc_z = e.acceleration.z;
        var acc_threshold = 10.0 / this.shake_sensitivity;
        var motion_now = (new Date).getTime();
        var motion_interval = Math.abs(motion_now - this.motion_last);
        // Show first slide if shake is stronger than threshold
        if ((acc_x > acc_threshold || acc_y > acc_threshold || acc_z > acc_threshold) && motion_interval > this.motion_break) {
            this.content.showSlide(0);
            this.motion_last = motion_now;
        }
    }
    // ---
    // Description: Toggles speaker nodes for current slide if available.
    // e: Event coming from double tap, null otherwise.
    // always_hide: If true, speaker nodes are hidden regardless of the current status.
    // ---
    toggleSpeakerNotes(e, always_hide) {
        always_hide = always_hide || false;
        // Get current status
        var speaker_notes_overlay = document.getElementById("speakernotes-overlay");
        var hidden = speaker_notes_overlay.classList.contains("hidden");
        // Hide speaker notes if necessary
        if (hidden == false || always_hide == true) {
            speaker_notes_overlay.classList.add("hidden");
            // Prevent default double tap event if notes were visible
            if (e != null && hidden == false) {
                e.preventDefault();
                e.stopPropagation();
            }
            return;
        }
        // Get current speaker notes (if there are any)
        var content_section = document.getElementById("content-section");
        var current_slide = content_section.getElementsByClassName("slide")[this.content.getCurrentSlideIndex()];
        var speaker_notes = (current_slide.getElementsByClassName("speakernotes").length == 1) ? current_slide.getElementsByClassName("speakernotes")[0] : null;
        // Show speaker notes and set new text if necessary
        if (speaker_notes != null) {
            speaker_notes_overlay.classList.remove("hidden");
            speaker_notes_overlay.innerHTML = '<div class="speakernotes-container">' + speaker_notes.innerHTML + '</div>';
            // Prevent default double tap event if notes were hidden
            if (e != null && hidden == true) {
                e.preventDefault();
                e.stopPropagation();
            }
        }
    }
}
exports.Rslidy = Rslidy;
function start() {
    //window.mdc.autoInit();
    window.rslidy = new Rslidy();
    window.rslidy.init();
}
window.onload = start;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// Class Utils
// Implements utility functions.
class Utils {
    // Methods
    // ---
    // Description: Constructor.
    // ---
    constructor() {
        this.debug_enabled = true;
        this.debug_only_error = false;
        this.color_info = "#ffbb66";
        this.color_error = "#ff0000";
    }
    // ---
    // Description: A simple debug method, can be modified later if needed.
    // message: The string to be printed.
    // error: Whether it is an error or not (optional).
    // ---
    debug(message, error) {
        error = error || false;
        var color = (error == true) ? this.color_error : this.color_info;
        if (this.debug_enabled == false || (error == false && this.debug_only_error == true))
            return;
        var prefix = (error ? "[ERROR]" : "[DEBUG]");
        console.log("%c " + prefix + " " + message, "color: " + color + ";");
    }
    // ---
    // Description: Returns the width of the slide.
    // aspect_ratio: The desired aspect ratio (or 0 for dynamic calculation).
    // custom_width: The custom width.
    // ---
    getSlideWidth(aspect_ratio, custom_width) {
        aspect_ratio = aspect_ratio || 0;
        if (aspect_ratio == 0)
            return window.outerWidth;
        var width = custom_width; // ...
        return width;
    }
    // ---
    // Description: Returns the height of the slide.
    // aspect_ratio: The desired aspect ratio (or 0 for dynamic calculation).
    // custom_width: The custom width.
    // ---
    getSlideHeight(aspect_ratio, custom_width) {
        aspect_ratio = aspect_ratio || 0;
        if (aspect_ratio == 0)
            return window.outerHeight;
        var width = custom_width;
        var height = width / aspect_ratio;
        return height;
    }
    // ---
    // Description: Returns a copy of the input, with all line breaks removed.
    // text: The string to remove the line breaks from.
    // ---
    removeLineBreaks(text) {
        return text.replace(/(\r\n|\n|\r)/gm, "");
    }
    // ---
    // Description: Returns the current aspect ratio.
    // ---
    getCurrentAspectRatio() {
        var window_width = window.innerWidth;
        var window_height = window.innerHeight;
        var current_aspect_ratio = window_width / window_height;
        return current_aspect_ratio;
    }
    ;
    // ---
    // Description: Gets the relative width of an element, with respect to the whole window.
    // element: Specifies the element to consider.
    // aspect_ratio: The desired aspect ratio (or 0 for dynamic calculation).
    // custom_width: The custom width.
    // ---
    getRelativeWidth(element, aspect_ratio, custom_width) {
        var window_width = (aspect_ratio == 0) ? window.outerWidth : custom_width;
        var element_width = element.clientWidth;
        var relative_width = element_width / window_width;
        return relative_width;
    }
    // ---
    // Description: Returns the integer representation of a character.
    // character: Specifies the character to convert.
    // ---
    toInt(character) {
        return 1 * character;
    }
    // ---
    // Description: Returns a 2-digit-representation of a number (e.g. "6" becomes "06", but "11" will still be "11").
    // num: Specify the number.
    // ---
    toTwoDigits(num) {
        return (("0" + num).slice(-2));
    }
    // ---
    // Description: Switches the existence of a class of each element in a specified list (ignores elements with class "ignore").
    // element_list: The list of elements.
    // class_name: The name of the class.
    // ---
    switchElementsClass(element_list, class_name) {
        for (var i = 0; i < element_list.length; i++) {
            if (element_list[i].classList.contains("ignore") == true)
                continue;
            if (element_list[i].classList.contains(class_name) == true)
                element_list[i].classList.remove(class_name);
            else
                element_list[i].classList.add(class_name);
        }
    }
    // ---
    // Description: Adds a class to an element if not already present
    // element_list: The list of elements.
    // class_name: The name of the class.
    // ---
    addElementsClass(element_list, class_name) {
        for (var i = 0; i < element_list.length; i++) {
            if (element_list[i].classList.length == 0 || element_list[i].classList.contains(class_name) == false) {
                element_list[i].classList.add(class_name);
            }
        }
    }
    // ---
    // Description: Inverts the color attribute of all elements in the specified list.
    // element_list: The list of elements.
    // low_light_mode: Specified whether colors should be inverted or reset.
    // ---
    invertElementsColor(element_list, low_light_mode) {
        low_light_mode = low_light_mode || false;
        for (var i = 0; i < element_list.length; i++) {
            // Continue if night mode is to be disabled
            if (low_light_mode == true) {
                element_list[i].style.color = "";
                continue;
            }
            // Invert color
            var color_rgb = getComputedStyle(element_list[i]).getPropertyValue("color");
            var color_hex = "#";
            var rgx = /\d+/g;
            var match;
            while ((match = rgx.exec(color_rgb)) != null) {
                var inverted = 255 - match[0];
                if (inverted < 16)
                    color_hex += "0";
                color_hex += inverted.toString(16);
            }
            element_list[i].style.color = color_hex;
        }
    }
    // ---
    // Description: Determines if a child element is currently fully visible in the scrollable area of a parent element.
    // ---
    childVisibleInParentScroll(child, parent) {
        var condition_1 = (child.offsetTop + child.clientHeight) > (parent.scrollTop + parent.clientHeight);
        var condition_2 = child.offsetTop < parent.scrollTop;
        if (condition_1 == true || condition_2 == true)
            return false;
        else
            return true;
    }
    htmlParse(htmlstr) {
        const template = document.createElement('template');
        template.innerHTML = htmlstr;
        return template.content.firstElementChild;
    }
    prependHtmlString(parent, html) {
        const view = this.htmlParse(html);
        parent.insertBefore(view, parent.firstChild);
        return view;
    }
    appendHtmlString(parent, html) {
        const view = this.htmlParse(html);
        parent.appendChild(view);
        return view;
    }
}
exports.Utils = Utils;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const html = `
    <div id="menu" class="hidden mdc-card"">
        <div class="menu-content">
            <a id="button-help" href="javaScript:void(0);"><i class="material-icons">help_outline</i></a>
        </div>
        <div class="menu-content">
        <a href="#" id="button-zoom-less"><i class="material-icons">remove</i></a>
        <a href="#" id="button-zoom-reset"><i class="material-icons">format_size</i></a> 
        <a href="#" id="button-zoom-more"><i class="material-icons">add</i></a> 
        </div>
        <div class="menu-content">
            <label>
                Tilt 
                <input type="checkbox" value="Tilt" id="checkbox-tilt" disabled>
            </label>
        </div>
        <div class="menu-content">
            <label>
                Shake 
                <input type="checkbox" value="Shake" id="checkbox-shake" disabled>
            </label>
        </div>
        <div class="menu-content">
            <label>
                Click Nav 
                <input type="checkbox" value="Tilt" id="checkbox-clicknav">
            </label>
        </div>
        <div class="menu-content">
            <label>
                Low Light Mode 
                <input type="checkbox" value="Low Light Mode" id="checkbox-lowlightmode">
            </label>
        </div>
    </div>`;
class SettingsComponent {
    constructor(parent, model) {
        this.model = model;
        this.view = window.rslidy.utils.prependHtmlString(parent, html);
        this.view.querySelector('#button-zoom-more').addEventListener('click', e => this.changeSlideZoom(e, 1));
        this.view.querySelector('#button-zoom-reset').addEventListener('click', e => this.changeSlideZoom(e, 0));
        this.view.querySelector('#button-zoom-less').addEventListener('click', e => this.changeSlideZoom(e, -1));
        this.view.querySelector("#button-help").addEventListener('click', e => {
            if (window.rslidy.close_menu_on_selection)
                window.rslidy.statusbar.menuToggleClicked(false);
            alert(window.rslidy.help_text);
        });
        this.view.querySelector("#checkbox-tilt").addEventListener('click', e => {
            if (window.rslidy.close_menu_on_selection)
                window.rslidy.statusbar.menuToggleClicked(false);
        });
        this.view.querySelector("#checkbox-shake").addEventListener('click', e => {
            if (window.rslidy.close_menu_on_selection)
                window.rslidy.statusbar.menuToggleClicked(false);
        });
        this.view.querySelector("#checkbox-clicknav").addEventListener('click', e => {
            if (window.rslidy.close_menu_on_selection)
                window.rslidy.statusbar.menuToggleClicked(false);
        });
        this.view.querySelector("#checkbox-lowlightmode").addEventListener('click', e => this.lowLightModeToggleClicked());
    }
    // ---
    // Description: Called whenever the night mode button is clicked.
    // ---
    lowLightModeToggleClicked() {
        // Invert everything
        window.rslidy.toggleLowLightMode();
        // Close menu if this.close_menu_on_selection == true
        if (window.rslidy.close_menu_on_selection == true)
            window.rslidy.statusbar.menuToggleClicked(false);
    }
    // ---
    // Description: Called whenever one of the text size buttons is clicked.
    // e: The event.
    // value: Specifies the zoom modifier (1 = more, -1 = less).
    // ---
    changeSlideZoom(e, value) {
        var slides_large = document.querySelectorAll('#content-section .slide');
        const rs = window.rslidy;
        for (var i = 0; i < slides_large.length; i++) {
            if (value == 0)
                slides_large[i].style.fontSize = "1.0em";
            var current_font_size = parseFloat(slides_large[i].style.fontSize);
            if ((current_font_size > rs.min_slide_zoom && value == -1) || (current_font_size < rs.max_slide_zoom && value == 1))
                slides_large[i].style.fontSize = current_font_size + (rs.zoom_step * value) + "em";
            else if (isNaN(current_font_size))
                slides_large[i].style.fontSize = (1.0 + (rs.zoom_step * value)) + "em";
        }
        // Adjust SVG replacements
        rs.adjustSVGReplacementsWidth();
        // Prevent default actions after event handling
        e.preventDefault();
    }
}
exports.SettingsComponent = SettingsComponent;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const html = `
    <div id="status-bar-area">
        <div id="status-bar">
            <div id="progress-bar"></div>
            <div id="status-bar-content">
            <button id="button-overview" class="mdc-button mdc-button--raised mdc-status-bar-button float-left" title="Thumbnails">
                <i class="material-icons">crop_original</i>                
            </button>

            <div class="hidden-on-mobile" id="status-bar-button-nav">
                <button id="status-bar-nav-button-first" class="mdc-button mdc-button--raised mdc-status-bar-button"  title="First Slide">
                    <i class="material-icons">first_page</i>
                    
                </button>
                <button id="status-bar-nav-button-previous" class="mdc-button mdc-button--raised mdc-status-bar-button" title="Previous Slide">
                    <i class="material-icons">navigate_before</i>                
                </button> 
                <div class="status-bar-slide" id="slide-input-container"><input value="1" id="slide-input" type="textbox" maxlength="3"></div>
                <div class="status-bar-slide" id="slide-caption"> /23</div>
                <button id="status-bar-nav-button-next" class="mdc-button mdc-button--raised mdc-status-bar-button"  title="Next Slide">
                    <i class="material-icons">navigate_next</i>
                </button>
                <button id="status-bar-nav-button-last" class="mdc-button mdc-button--raised mdc-status-bar-button" title="Last Slide">
                    <i class="material-icons">last_page</i>                
                </button>
            </div>
            
            <button id="button-menu" class="mdc-button mdc-button--raised mdc-status-bar-button float-right" title="Settings">            
                <i class="material-icons">more_vert</i>
            </button>
            <button id="button-toc" class="mdc-button mdc-button--raised mdc-status-bar-button float-right" title="Table of Contents">
                <i class="material-icons">toc</i>
            </button>
            <button id="status-bar-pin-button" class="mdc-button mdc-button--raised mdc-status-bar-button float-right" title = "Unpin the status bar">
                <i class="material-icons">lock</i>
            </button>
        
            <div class="float-right" id="timer">00:00</div>
            </div>
        </div>
    </div>`;
class StatusbarComponent {
    constructor(parent, model) {
        this.isInArea = false;
        this.model = model;
        this.view = window.rslidy.utils.prependHtmlString(parent, html);
        this.view.querySelector("#button-overview")
            .addEventListener('click', () => this.overviewToggleClicked(false));
        this.view.querySelector("#button-toc")
            .addEventListener('click', () => this.tocToggleClicked(false));
        this.view.querySelector("#status-bar-nav-button-first")
            .addEventListener('click', () => window.rslidy.content.navFirst());
        this.view.querySelector("#status-bar-nav-button-previous")
            .addEventListener('click', () => window.rslidy.content.navPrevious());
        this.view.querySelector("#status-bar-nav-button-next")
            .addEventListener('click', () => window.rslidy.content.navNext());
        this.view.querySelector("#status-bar-nav-button-last")
            .addEventListener('click', () => window.rslidy.content.navLast());
        this.view.querySelector("#status-bar-pin-button")
            .addEventListener('click', () => this.pinToggleClicked(false));
        this.view.querySelector("#timer")
            .addEventListener('click', () => window.rslidy.toggleTimer());
        this.view.querySelector("#slide-caption")
            .addEventListener('click', () => this.tocToggleClicked(false));
        this.view.querySelector("#button-menu")
            .addEventListener('click', () => this.menuToggleClicked(false));
        this.view.querySelector("#slide-input")
            .addEventListener('keyup', e => window.rslidy.slideInputKeyPressed(e));
        this.mouseOverHandler = function (evt) {
            this.mouseEnter();
        }.bind(this);
        this.mouseOffHandler = function (evt) {
            this.mouseLeave();
        }.bind(this);
    }
    // ---
    // Description: Called whenever the overview button is clicked.
    // close_only: Specifies whether the overview should only be closed.
    // ---
    overviewToggleClicked(close_only) {
        close_only = close_only || false;
        const rs = window.rslidy;
        // Set new checkbox status (don't do this if overview was open AND on links before)
        var content_section = document.getElementById("content-section");
        if (!(content_section.classList.contains("shifted-left") == true && rs.full_overview == false))
            rs.utils.switchElementsClass([content_section], "shifted-left"); // Fix for Chrome on iOS
        // Set overview to thumbnails
        rs.full_overview = true;
    }
    // ---
    // Description: Called whenever the toc button is clicked.
    // close_only: Specifies whether the overview should only be closed.
    // ---
    tocToggleClicked(close_only) {
        close_only = close_only || false;
        const rs = window.rslidy;
        // Set new checkbox status (don't do this if overview was open AND on links before)
        var content_section = document.getElementById("content-section");
        if (!(content_section.classList.contains("shifted-right") == true && rs.full_overview == true))
            rs.utils.switchElementsClass([content_section], "shifted-right"); // Fix for Chrome on iOS
        // Set overview to thumbnails
        rs.full_overview = false;
    }
    // ---
    // Description: Called whenever the menu button is clicked.
    // close_only: Specifies whether the menu should only be closed.
    // ---
    menuToggleClicked(close_only) {
        close_only = close_only || false;
        // Toggle menu show status
        var menu = document.getElementById("menu");
        if (menu.classList.contains("hidden") == true)
            menu.classList.remove("hidden");
        else
            menu.classList.add("hidden");
    }
    // ---
    // Description: Called whenever the toc button is clicked.
    // close_only: Specifies whether the overview should only be closed.
    // ---
    pinToggleClicked(close_only) {
        close_only = close_only || false;
        // Toggle menu show status
        // NEW: fade in/out effects
        var pin_button = document.getElementById("status-bar-pin-button");
        var status_bar = document.getElementById("status-bar");
        //var indicator_left = document.getElementById("progress-bar-indicator-left");
        //var indicator_right = document.getElementById("progress-bar-indicator-right");
        if (pin_button.title == "Pin the status bar") {
            pin_button.title = "Unpin the status bar";
            status_bar.style.bottom = '0';
            pin_button.innerHTML = '<i class="material-icons">lock</i>';
            document.getElementById('status-bar-area')
                .removeEventListener('mouseenter', this.mouseOverHandler);
            document.getElementById('status-bar-area')
                .removeEventListener('mouseleave', this.mouseOffHandler);
        }
        else {
            pin_button.title = "Pin the status bar";
            pin_button.innerHTML = '<i class="material-icons">lock_open</i>';
            document.getElementById('status-bar-area')
                .addEventListener('mouseenter', this.mouseOverHandler);
            document.getElementById('status-bar-area')
                .addEventListener('mouseleave', this.mouseOffHandler);
        }
    }
    mouseEnter() {
        this.isInArea = true;
        this.statusBarTransitionBottom('status-bar', '0em');
        this.statusBarTransitionBottom('status-bar-area', '0em');
        this.statusBarTransitionMargin('overview-toc', '3.2em');
        this.statusBarTransitionMargin('overview-slides', '3.2em');
        this.statusBarTransitionMargin('content-section', '3.2em');
    }
    mouseLeave() {
        this.isInArea = false;
        setTimeout(() => {
            if (this.isInArea) {
                return;
            }
            this.statusBarTransitionBottom('status-bar', '-1.9em');
            this.statusBarTransitionBottom('status-bar-area', '-1em');
            this.statusBarTransitionMargin('overview-toc', '0.3em');
            this.statusBarTransitionMargin('overview-slides', '0.3em');
            this.statusBarTransitionMargin('content-section', '0.3em');
        }, 1000);
    }
    statusBarTransitionBottom(name, value) {
        var element = document.getElementById(name);
        element.style.bottom = value;
    }
    statusBarTransitionMargin(name, value) {
        var element = document.getElementById(name);
        element.style.marginBottom = value;
    }
}
exports.StatusbarComponent = StatusbarComponent;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const htmlToc = `
    <div id="overview-toc"></div>`;
const htmlSlides = `
    <div id="overview-slides"></div>`;
const thumbnailHtml = (idx, title, xofy, slide) => `
    <div class="slide-thumbnail mdc-card" data-slideindex="${idx}">
        <div class="thumbnail-caption noselect">${xofy}</div>
        <div class="slide-clickelement" data-slideindex="${idx}">
            <div class="overview-item noselect" data-slideindex="${idx}">${slide}</div>
        </div>
    </div>`;
//const captionHtml = (idx, title, xofy)=> `    
const linkHtml = (idx, title, xofy) => `    
    <div class="slide-link" data-slideindex="${idx}">${title}</div>`;
const shiftLeft = "shifted-left";
const shiftRight = "shifted-right";
var OverviewType;
(function (OverviewType) {
    OverviewType[OverviewType["TableOfContents"] = 0] = "TableOfContents";
    OverviewType[OverviewType["SlideOverview"] = 1] = "SlideOverview";
})(OverviewType = exports.OverviewType || (exports.OverviewType = {}));
class OverviewComponent {
    constructor(parent, model, type) {
        this.type = type;
        this.model = model;
        const original_slides = model;
        console.assert(original_slides.length === window.rslidy.num_slides);
        if (this.type == OverviewType.SlideOverview) {
            this.view = window.rslidy.utils.prependHtmlString(parent, htmlSlides);
        }
        else if (this.type == OverviewType.TableOfContents) {
            this.view = window.rslidy.utils.prependHtmlString(parent, htmlToc);
        }
        for (var i = 0; i < window.rslidy.num_slides; i++) {
            const slide = original_slides[i];
            const slideHtml = slide.outerHTML;
            const title = (i + 1) + '. ' + this.getSlideHeading(slide);
            const xofy = (i + 1) + ' / ' + window.rslidy.num_slides;
            if (this.type == OverviewType.SlideOverview) {
                const thumbnail = window.rslidy.utils.appendHtmlString(this.view, thumbnailHtml(i, title, xofy, slideHtml));
                thumbnail.addEventListener('click', e => this.slideSelected(e));
            }
            else if (this.type == OverviewType.TableOfContents) {
                const link = window.rslidy.utils.appendHtmlString(this.view, linkHtml(i, title, xofy));
                link.addEventListener('click', e => this.slideSelected(e));
            }
            this.view.classList.add("overview");
        }
        if (this.type == OverviewType.SlideOverview) {
            this.adjustOverviewPanel();
        }
    }
    // ---
    // Description: Adjusts the aspect ratio and display sizes of the thumbnail images in the overview menu.
    // ---
    adjustOverviewPanel() {
        // Get items
        var thumbnail_wrappers = document.getElementsByClassName("slide-thumbnail");
        var overview_items = document.getElementsByClassName("overview-item");
        // Get the percentage of width pixels of the overview section with respect to window.outerWidth
        var aspect_ratio = (window.rslidy.custom_aspect_ratio != 0) ? window.rslidy.custom_aspect_ratio : window.rslidy.utils.getCurrentAspectRatio();
        var overview_slide_zoom = window.rslidy.overview_slide_zoom;
        var custom_width = window.rslidy.custom_width;
        var final_width = custom_width / overview_slide_zoom;
        var overview_element = document.getElementsByClassName("overview")[0];
        var relative_width = window.rslidy.utils.getRelativeWidth(overview_element, aspect_ratio, final_width);
        for (var i = 0; i < window.rslidy.num_slides; i++) {
            // 1. Set width and height of the overview element to outerWidth and outerHeight, respectively
            overview_items[i].style.width = window.rslidy.utils.getSlideWidth(aspect_ratio, final_width) + "px";
            overview_items[i].style.height = window.rslidy.utils.getSlideHeight(aspect_ratio, final_width) + "px";
            // 2. Do the transformation of the overview element now with relative_width (browser compatibility)
            var scale_value = "scale3d(" + relative_width + ", " + relative_width + ", " + relative_width + ")";
            var origin_value = "0px 0px 0px";
            overview_items[i].style.transform = scale_value; // safety first
            overview_items[i].style.transformOrigin = origin_value; // safety first
            overview_items[i].style.MozTransform = scale_value;
            overview_items[i].style.MozTransformOrigin = origin_value;
            overview_items[i].style.webkitTransform = scale_value;
            overview_items[i].style.webkitTransformOrigin = origin_value;
            overview_items[i].style.msTransform = scale_value;
            overview_items[i].style.msTransformOrigin = origin_value;
            // 3. Now, set the width pixels of the wrapper element to the overview width pixels and calculate its height with the aspect ratio
            const w = overview_element.clientWidth;
            const h = w / (window.rslidy.utils.getSlideWidth(aspect_ratio, final_width) / window.rslidy.utils.getSlideHeight(aspect_ratio, final_width));
            thumbnail_wrappers[i].style.width = w - 20 + "px";
            thumbnail_wrappers[i].style.height = h - 20 + "px";
        }
    }
    // ---
    // Description: Returns the heading of a slide if available (or "slide" if not found).
    // slide_element: The slide element to get the heading from.
    // ---
    getSlideHeading(slide_element) {
        if (slide_element == null)
            return "";
        var slide_headers = slide_element.getElementsByTagName("h1");
        if (slide_headers.length > 0)
            return slide_headers[0].innerHTML;
        else
            return "slide";
    }
    // ---
    // Description: Called whenever a slide thumbnail in the overview gets clicked.
    // e: Event.
    // ---
    slideSelected(e) {
        // Get the click target
        var target = e.target;
        // Fix for z-index bug on iOS
        while (target.className != "slide-clickelement" && target.className != "slide-link")
            target = target.parentElement;
        // Get the index of the slide
        var slide_index = Number(target.dataset.slideindex);
        // Switch to this slide
        window.rslidy.content.showSlide(slide_index);
        // Close overview menu if desired
        if (window.rslidy.close_navigation_on_selection == true) {
            var content_section = document.getElementById("content-section");
            switch (this.type) {
                case OverviewType.SlideOverview:
                    window.rslidy.utils.switchElementsClass([content_section], shiftLeft);
                    break;
                case OverviewType.TableOfContents:
                    window.rslidy.utils.switchElementsClass([content_section], shiftRight);
                    break;
            }
        }
        // Prevent link clicking (iOS)
        e.preventDefault();
    }
}
exports.OverviewComponent = OverviewComponent;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const slide_transition_1 = __webpack_require__(6);
const html = body_old => `<div id="content-section">${body_old}</div>`;
class ContentComponent {
    constructor(parent, model) {
        this.currentSlideIndex = -1;
        this.model = model;
        this.view = window.rslidy.utils.appendHtmlString(parent, html(model));
        this.view.querySelectorAll('.slide').forEach((e, idx) => e.id = `slide-${idx}`);
        this.slideTransition = new slide_transition_1.SlideTransition();
        const rs = window.rslidy;
        this.view.addEventListener('mousedown', e => { rs.start_x = e.clientX; rs.start_y = e.clientY; });
        this.view.addEventListener('mouseup', e => {
            if (rs.start_x == e.clientX && rs.start_y == e.clientY
                && document.getElementById("checkbox-clicknav").checked) {
                this.navNext();
            }
        });
        // Custom touch listeners, since hammer.js gives problems        
        this.view.addEventListener('touchstart', e => this.onTouchstart(e));
        this.view.addEventListener('touchmove', e => this.onTouchmove(e));
        this.view.addEventListener('touchend', e => this.onTouchend(e));
        this.doStyleAdaptions();
    }
    // ---
    // Description: Used for final style adaptions.
    // ---
    doStyleAdaptions() {
        const rs = window.rslidy;
        // Start in night mode if set
        if (rs.start_in_low_light_mode == true) {
            rs.toggleLowLightMode();
            document.getElementById("checkbox-lowlightmode").checked = true;
        }
        // Block slide text selection if set
        if (rs.block_slide_text_selection == true) {
            var content_section = document.getElementById("content-section");
            var original_slides = content_section.getElementsByClassName("slide");
            for (var i = 0; i < original_slides.length; i++)
                original_slides[i].classList.add("noselect");
        }
    }
    // ---
    // Description: Called whenever the user begins to touch the body area.
    // e: Event.
    // ---
    onTouchstart(e) {
        const rs = window.rslidy;
        // Register last tap
        var tap_previous = rs.tap_last;
        rs.tap_last = (new Date).getTime();
        var tap_delay = rs.tap_last - tap_previous;
        // Toggle speaker notes on double tap
        if (tap_delay <= rs.doubletap_delay) {
            rs.toggleSpeakerNotes(e, false);
        }
        // Register touch event
        var touch = e.touches[0];
        // Set new values and reset old values
        rs.start_x = touch.pageX;
        rs.start_y = touch.pageY;
        rs.delta_x = 0;
        rs.delta_y = 0;
    }
    // ---
    // Description: Called whenever the user moves the finger while touching the body area.
    // e: Event.
    // ---
    onTouchmove(e) {
        const rs = window.rslidy;
        // Update values
        var touch = e.touches[0];
        var delta_x_old = rs.delta_x;
        rs.delta_x = touch.pageX - rs.start_x;
        rs.delta_y = touch.pageY - rs.start_y;
        // If the delta_x position has changed a lot, the user is swiping and the content does not need to be scrolled!
        if (Math.abs(rs.delta_x - delta_x_old) > 10)
            e.preventDefault();
    }
    // ---
    // Description: Called whenever the stops touching the body area.
    // e: Event.
    // ---
    onTouchend(e) {
        const rs = window.rslidy;
        // Register old values and calculate absolutes
        var touch_duration = (new Date).getTime() - rs.tap_last;
        var delta_x = rs.delta_x;
        var delta_y = rs.delta_y;
        var delta_x_abs = Math.abs(delta_x);
        var delta_y_abs = Math.abs(delta_y);
        // Handle the swipe event if the touch duration was shorter than a specified threshold
        // Also, the movement should be mainly on the x axis (x_movement > rs.swipe_y_limiter * y_movement)
        if (touch_duration < rs.swipe_max_duration && (delta_x_abs > rs.swipe_threshold || delta_y_abs > rs.swipe_threshold)) {
            if (delta_x_abs > rs.swipe_y_limiter * delta_y_abs) {
                rs.shift_pressed = true;
                if (delta_x < 0)
                    this.navNext();
                else
                    this.navPrevious();
                rs.shift_pressed = false;
                e.preventDefault(); // Seems to improve scrolling experience on iOS devices somehow
            }
        }
    }
    // ---
    // Description: Returns the number of incremental list items on a slide.
    // slide_index: The index of the slide (0-indexed).
    // only_visible: Returns only the number of currently visible items (optional).
    // ---
    getNumIncrItems(slide_index, only_visible) {
        only_visible = only_visible || false;
        // Out of bounds check
        if (slide_index < 0 || slide_index >= window.rslidy.num_slides)
            return -1;
        var content_section = document.getElementById("content-section");
        var slide = content_section.getElementsByClassName("slide")[slide_index];
        var incremental_items = slide.querySelectorAll('ul.incremental li');
        if (only_visible == false)
            return incremental_items.length;
        else {
            var counter = 0;
            for (var i = 0; i < incremental_items.length; i++) {
                if (incremental_items[i].classList.contains("invisible") == false)
                    counter++;
            }
            return counter;
        }
    }
    // ---
    // Description: Jumps to the next slide (or next bullet point).
    // ---
    navNext() {
        var current_index = this.currentSlideIndex;
        const rs = window.rslidy;
        rs.imageViewer.close();
        // Check for incremental items on current slide
        if (this.getNumIncrItems(current_index, false) > 0) {
            var num_incr_items = this.getNumIncrItems(current_index, false);
            var num_incr_items_shown = this.getNumIncrItems(current_index, true);
            if (num_incr_items > num_incr_items_shown) {
                if (rs.shift_pressed == false)
                    this.showItemsUpToN(num_incr_items_shown + 1);
                else
                    this.showItemsUpToN(num_incr_items);
                return;
            }
        }
        // Change slide
        var new_index = current_index + 1;
        this.showSlide(new_index);
        // Check for incremental items on next slide
        if (this.getNumIncrItems(new_index, false) > 0) {
            var num_incr_items = this.getNumIncrItems(new_index, false);
            if (rs.shift_pressed == false)
                this.showItemsUpToN(1);
            else
                this.showItemsUpToN(num_incr_items);
        }
    }
    navLast() {
        // Change slide
        const rs = window.rslidy;
        var new_index = rs.num_slides - 1;
        this.showSlide(new_index);
        // Check for incremental items on next slide
        if (this.getNumIncrItems(new_index, false) > 0) {
            var num_incr_items = this.getNumIncrItems(new_index, false);
            if (rs.shift_pressed == false)
                this.showItemsUpToN(1);
            else
                this.showItemsUpToN(num_incr_items);
        }
    }
    // ---
    // Description: Jumps to the previous slide (or previous bullet point).
    // ---
    navPrevious() {
        var current_index = this.currentSlideIndex;
        // Check for incremental items on current slide
        var num_incr_items_shown = this.getNumIncrItems(current_index, true);
        if (this.getNumIncrItems(current_index, false) > 0 && num_incr_items_shown > 1) {
            if (window.rslidy.shift_pressed == false) {
                this.showItemsUpToN(num_incr_items_shown - 1);
                return;
            }
            else {
                this.showItemsUpToN(1);
                return;
            }
        }
        // Change slide
        var new_index = current_index - 1;
        this.showSlide(new_index);
        // Check for incremental items on previous slide
        if (this.getNumIncrItems(new_index, false) > 0) {
            var num_incr_items = this.getNumIncrItems(new_index, false);
            this.showItemsUpToN(num_incr_items);
        }
    }
    navFirst() {
        var new_index = 0;
        this.showSlide(new_index);
        // Check for incremental items on previous slide
        if (this.getNumIncrItems(new_index, false) > 0) {
            var num_incr_items = this.getNumIncrItems(new_index, false);
            this.showItemsUpToN(num_incr_items);
        }
    }
    // ---
    // Description: Shows the first n bullet points and hides the rest.
    // n: Specifies the last incremental item to show.
    // ---
    showItemsUpToN(n) {
        var content_section = document.getElementById("content-section");
        var current_slide = content_section.getElementsByClassName("slide")[this.currentSlideIndex];
        var incr_items = current_slide.querySelectorAll("ul.incremental li");
        // Show items with index < n, hide items with index >= n
        var counter = 0;
        for (var i = 0; i < incr_items.length; i++) {
            if (counter < n)
                incr_items[i].classList.remove("invisible");
            else
                incr_items[i].classList.add("invisible");
            counter++;
        }
    }
    //
    // Slide navigation methods
    //
    // ---
    // Description: Hides all slides and shows specified slide then.
    // slide_index: The index of the slide (0-indexed).
    // ---
    showSlide(targetSlideIndex) {
        const rs = window.rslidy;
        rs.imageViewer.close();
        if (targetSlideIndex < 0 && this.currentSlideIndex < 0)
            targetSlideIndex = 0;
        if (targetSlideIndex < 0 || targetSlideIndex >= rs.num_slides || this.currentSlideIndex == targetSlideIndex)
            return;
        this.slideTransition.doSlideTransition(this.currentSlideIndex, targetSlideIndex);
        var progress_bar = document.getElementById("progress-bar");
        progress_bar.style.width = 'calc(100%*' + (targetSlideIndex + 1) / rs.num_slides + ')';
        // Hide speaker nodes
        rs.toggleSpeakerNotes(null, true);
        var url_parts = window.location.href.split(rs.url_delimiter);
        // Set 1-indexed value and new url
        var slide_index_one_indexed = rs.utils.toInt(targetSlideIndex) + 1;
        window.location.href = url_parts[0] + rs.url_delimiter + slide_index_one_indexed;
        // Update slide caption
        var slide_caption = document.getElementById("slide-caption");
        slide_caption.innerHTML = " /" + rs.num_slides;
        var slide_input = document.getElementById("slide-input");
        slide_input.value = slide_index_one_indexed;
        this.currentSlideIndex = targetSlideIndex;
        return;
    }
}
exports.ContentComponent = ContentComponent;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class SlideTransition {
    constructor() {
        this.animationTypeOpacity = "opacity";
        this.animationTypeSlideIn = "slidein";
        this.animationTypeScaleUp = "scaleup";
        this.rs = window.rslidy;
        this.contentSection = document.getElementById("content-section");
        this.slides = this.contentSection.getElementsByClassName("slide");
        this.slideThumbnails = document.getElementsByClassName("slide-thumbnail");
        let bodyClasses = document.getElementsByTagName("body")[0].classList;
        if (bodyClasses.contains("animated")) {
            if (bodyClasses.contains(this.animationTypeOpacity)) {
                this.setSlideTransitionClass(this.animationTypeOpacity);
            }
            if (bodyClasses.contains(this.animationTypeSlideIn)) {
                this.setSlideTransitionClass(this.animationTypeSlideIn);
            }
            if (bodyClasses.contains(this.animationTypeScaleUp)) {
                this.setSlideTransitionClass(this.animationTypeScaleUp);
            }
        }
        // Hide all slides and remove selected effect
        for (var i = 0; i < this.slides.length; i++) {
            this.slides[i].classList.add("hidden");
            this.slideThumbnails[i].classList.remove("slide-selected");
        }
    }
    setSlideTransitionClass(transitionClass) {
        for (let slide of this.slides) {
            slide.classList.add("animated");
            slide.classList.add(transitionClass);
        }
    }
    doSlideTransition(currentSlideIndex, targetSlideIndex) {
        if (currentSlideIndex == targetSlideIndex) {
            return;
        }
        if (currentSlideIndex >= 0) {
            this.slides[currentSlideIndex].classList.remove("animated");
            setTimeout(() => {
                // restarts the animation
                this.slides[currentSlideIndex].classList.add("animated");
            }, 10);
            setTimeout(() => {
                this.slides[currentSlideIndex].classList.add("hidden");
            }, 500);
            this.slideThumbnails[currentSlideIndex].classList.remove("slide-selected");
        }
        if (currentSlideIndex >= 0) {
            this.slides[currentSlideIndex].classList.remove("forwards");
            this.slides[currentSlideIndex].classList.add("backwards");
        }
        this.slides[targetSlideIndex].classList.remove("backwards");
        this.slides[targetSlideIndex].classList.add("forwards");
        // Show specified slide and add selected effect
        this.slides[targetSlideIndex].classList.remove("hidden");
        this.slideThumbnails[targetSlideIndex].classList.add("slide-selected");
        // Scroll to it in the overview, but only if the element is not already in the view (and decide on block start/end)
        var child = this.slideThumbnails[targetSlideIndex];
        var parent = document.getElementById("overview-slides");
        if (this.rs.utils.childVisibleInParentScroll(child, parent) == false) {
            const scroll_block_switch = (currentSlideIndex < targetSlideIndex) ? false : true;
            this.slideThumbnails[targetSlideIndex].scrollIntoView(scroll_block_switch);
        }
        // Scroll to the top of this slide
        this.contentSection.scrollTop = 0;
    }
}
exports.SlideTransition = SlideTransition;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const html = `<div class="image-viewer">
    <span class="image-viewer-close">&times;</span>

    <div class="image-viewer-container">
        <img draggable="false" class="image-viewer-content">
    </div>
    <div class="image-viewer-caption"></div>

    <span class="image-viewer-zoomReset">&#x25A2;</span>
    <span class="image-viewer-zoomIn">&plus;</span>
    <span class="image-viewer-zoomOut">&minus;</span>
</div>`;
class ImageViewerComponent {
    constructor(parent) {
        this.zoomFactor = 1.0;
        this.mouseDragStartX = 0;
        this.mouseDragStartY = 0;
        this.imageOffsetX = 0;
        this.imageOffsetY = 0;
        this.setImageViewerTags();
        this.view = window.rslidy.utils.prependHtmlString(parent, html);
        this.images = document.getElementsByClassName('slide-image');
        this.container = this.view.getElementsByClassName("image-viewer-container")[0];
        this.captionText = this.view.getElementsByClassName("image-viewer-caption")[0];
        this.modalImg = this.view.getElementsByClassName("image-viewer-content")[0];
        this.addImageOnClickHandlers();
        this.addButtonHandlers();
        this.addMouseEventListeners();
    }
    close() {
        this.modalImg.classList.add("transition-enabled");
        this.view.style.display = "none";
        this.zoomFactor = 1.0;
    }
    setImageViewerTags() {
        var slides = document.getElementsByClassName("slide");
        let imgs = new Array();
        for (let slide of slides) {
            var imgsThisSlide = slide.getElementsByTagName("img");
            for (let img of imgsThisSlide) {
                imgs.push(img);
            }
        }
        window.rslidy.utils.addElementsClass(imgs, "slide-image");
    }
    addImageOnClickHandlers() {
        for (var i = 0; i < this.images.length; i++) {
            let image = this.images.item(i);
            image.onclick = () => {
                this.view.style.display = "block";
                this.modalImg.src = image.src;
                var theImage = new Image();
                theImage.src = image.src;
                this.imageWidth = theImage.width;
                this.imageHeight = theImage.height;
                // fix for firefox, which cannot 
                if (this.imageWidth == 0) {
                    this.imageWidth = this.modalImg.width;
                }
                if (this.imageHeight == 0) {
                    this.imageHeight = this.modalImg.height;
                }
                this.containerWidth = this.container.clientWidth;
                this.containerHeight = this.container.clientHeight;
                this.initialZoom();
                this.captionText.innerHTML = image.alt;
                this.isInsideContainer = true;
            };
        }
    }
    addButtonHandlers() {
        var spanClose = this.view.getElementsByClassName("image-viewer-close")[0];
        spanClose.addEventListener('click', () => {
            this.close();
        });
        var spanZoomIn = this.view.getElementsByClassName("image-viewer-zoomIn")[0];
        spanZoomIn.addEventListener('click', () => {
            this.zoomIn();
        });
        var spanZoomOut = this.view.getElementsByClassName("image-viewer-zoomOut")[0];
        spanZoomOut.addEventListener('click', () => {
            this.zoomOut();
        });
        var spanZoomReset = document.getElementsByClassName("image-viewer-zoomReset")[0];
        spanZoomReset.addEventListener('click', () => {
            this.initialZoom();
        });
    }
    addMouseEventListeners() {
        var mouseDown = false;
        this.container.addEventListener("mouseenter", (mouseDownEvent) => { this.isInsideContainer = true; });
        this.container.addEventListener("mouseleave", (mouseDownEvent) => { this.isInsideContainer = false; });
        this.view.addEventListener("mousewheel", (mouseWheelEvent) => {
            mouseWheelEvent.preventDefault();
            if (!this.isInsideContainer) {
                return;
            }
            var e = window.event || e; // old IE support
            var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail)));
            if (delta > 0) {
                this.zoomIn();
            }
            else {
                this.zoomOut();
            }
        });
        this.view.addEventListener("mousedown", (mouseDownEvent) => {
            mouseDownEvent.preventDefault();
            if (!this.isInsideContainer) {
                return;
            }
            this.mouseDragStartX = mouseDownEvent.clientX;
            this.mouseDragStartY = mouseDownEvent.clientY;
            this.modalImg.classList.remove("transition-enabled");
            mouseDown = true;
        });
        this.view.addEventListener("mousemove", (mouseMoveEvent) => {
            mouseMoveEvent.preventDefault();
            if (!mouseDown) {
                return;
            }
            this.imageOffsetX = (this.imageOffsetX + mouseMoveEvent.clientX - this.mouseDragStartX);
            this.imageOffsetY = (this.imageOffsetY + mouseMoveEvent.clientY - this.mouseDragStartY);
            this.mouseDragStartX = mouseMoveEvent.clientX;
            this.mouseDragStartY = mouseMoveEvent.clientY;
            this.applyOffset();
        });
        this.view.addEventListener("mouseup", (mouseUpEvent) => {
            mouseDown = false;
        });
    }
    zoomIn() {
        this.modalImg.classList.add("transition-enabled");
        this.zoomFactor *= 1.2;
        this.imageOffsetX = this.containerWidth / 2.0 - (-this.imageOffsetX + (this.containerWidth / 2.0)) * 1.2;
        this.imageOffsetY = this.containerHeight / 2.0 - (-this.imageOffsetY + (this.containerHeight / 2.0)) * 1.2;
        this.modalImg.style.width = this.imageWidth * this.zoomFactor + 'px';
        this.modalImg.style.height = this.imageHeight * this.zoomFactor + 'px';
        this.applyOffset();
    }
    zoomOut() {
        this.modalImg.classList.add("transition-enabled");
        var zoomBefore = this.zoomFactor;
        this.zoomFactor /= 1.2;
        if (this.zoomFactor < this.initialZoomFactor) {
            this.zoomFactor = this.initialZoomFactor;
        }
        this.imageOffsetX = this.containerWidth / 2.0 - (-this.imageOffsetX + (this.containerWidth / 2.0)) / (zoomBefore / this.zoomFactor);
        this.imageOffsetY = this.containerHeight / 2.0 - (-this.imageOffsetY + (this.containerHeight / 2.0)) / (zoomBefore / this.zoomFactor);
        this.modalImg.style.width = this.imageWidth * this.zoomFactor + 'px';
        this.modalImg.style.height = this.imageHeight * this.zoomFactor + 'px';
        this.applyOffset();
    }
    applyOffset() {
        var currentImageWidth = this.imageWidth * this.zoomFactor;
        var currentImageHeight = this.imageHeight * this.zoomFactor;
        if (currentImageWidth <= this.containerWidth) {
            this.imageOffsetX = (this.containerWidth - currentImageWidth) / 2.0;
        }
        else {
            if (this.containerWidth - this.imageOffsetX >= currentImageWidth) {
                this.imageOffsetX = this.containerWidth - currentImageWidth;
            }
            else if (this.imageOffsetX > 0) {
                this.imageOffsetX = 0;
            }
        }
        if (currentImageHeight <= this.containerHeight) {
            this.imageOffsetY = (this.containerHeight - currentImageHeight) / 2.0;
        }
        else {
            if (this.containerHeight - this.imageOffsetY >= currentImageHeight) {
                this.imageOffsetY = this.containerHeight - currentImageHeight;
            }
            else if (this.imageOffsetY > 0) {
                this.imageOffsetY = 0;
            }
        }
        this.modalImg.style.left = this.imageOffsetX + 'px';
        this.modalImg.style.top = this.imageOffsetY + 'px';
    }
    initialZoom() {
        var aspectImg = this.imageWidth / this.imageHeight;
        var aspectContainer = this.containerWidth / this.containerHeight;
        if (aspectContainer > aspectImg) {
            this.initialZoomFactor = this.containerHeight / this.imageHeight;
            this.imageOffsetX = (this.containerWidth - this.imageWidth * this.zoomFactor) / 2.0;
        }
        else {
            this.initialZoomFactor = this.containerWidth / this.imageWidth;
            this.imageOffsetY = (this.containerHeight - this.imageHeight * this.zoomFactor) / 2.0;
        }
        this.zoomFactor = this.initialZoomFactor;
        this.modalImg.style.width = this.imageWidth * this.zoomFactor + "px";
        this.modalImg.style.height = this.imageHeight * this.zoomFactor + "px";
        this.applyOffset();
    }
}
exports.ImageViewerComponent = ImageViewerComponent;


/***/ })
/******/ ]);
//# sourceMappingURL=rslidy.min.js.map