<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
    <head>
    <title>Hyperbolic tree</title>
    <meta charset="UTF-8" />
    
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="dcterms.rightsHolder" content="Copyright © 2018 Glatzhofer Michael">
    
    <link rel="stylesheet" href="d3-hypertree-light.css" id="ldswitch">        

    <script src="d3-hypertree.js"></script>
    </head>
    <style>
        @font-face {
            font-family: 'Roboto';
            font-style: normal;
            font-weight: 200;
            src: url('fonts/roboto/Roboto-Light.woff2') format('woff2');
        }
        @font-face {
            font-family: 'NotoColorEmoji';
            src: url('fonts/noto/NotoColorEmoji.ttf') format('truetype');
        }    
        @font-face {
            font-family: 'Roboto';
            font-style: normal;
            font-weight: 200;    
            src: url('fonts/roboto/Roboto-Light.woff2') format('woff2');
        }                    
        body {
            font-family: 'Roboto';
            font-weight: lighter;
            touch-action: none;
        }
    </style>
    <body>        
        <script>
            const π = Math.PI
            // helper functions. used to calculate node size (radius)
            const hasLazy =        n=> (n.hasOutChildren && n.isOutλ)
            const isLeaf =         n=> !n.children || !n.children.length
            const isRoot =         n=> !n.parent 
            
            var nodeInitR =        (c)=> (ud, d)=> c * ((d.children && d.parent) ? innerNodeScale(d) : 1)     
            var nodeInitRNoInner = (c)=> (ud, d)=> c
            var nodeScale =        d=> d.distScale * (hasLazy(d) ? .8 : 1)    
            var nodeScaleNoInner = d=> d.distScale    
            var innerNodeScale =   d=> d.precalc.weightScale
            // distScale: remove to disable distance effect
            //var arcWidth =         d=> .025 * d.distScale * d.precalc.weightScale
            var arcWidth =         d=> .01 * d.precalc.weightScale
            // constructs a new hypertree component.
            // ht variable can be used later on to modify component
            // or start animations
            const ht = new hyt.Hypertree(
                { 
                    // parent html element of the component
                    // existing children of the parent element are removed.
                    // this way, it is simple to replace a hypertree by another
                    parent: document.body 
                },
                { 
                    // this function is called on initialization.
                    // the function must return a d3-hierarchy object
                    // https://github.com/d3/d3-hierarchy
                    dataloader: hyt.loaders.generators.nT1,
                    // dataInitBFS is called each time after data is set.
                    // node properties which do not change during runtime, 
                    // should be set in this function.
                    // this way calculations are not necessary for each frame.
                    dataInitBFS: (ht, n)=> {
                        if (n.mergeId == 12)
                            n.precalc.imageHref = 'img/example.png'         
                    }, 
                    // is called when language is changed, 
                    // otherwise similar to dataInitBFS.
                    // typically node labels are calculated in this function.
                    langInitBFS: (ht, n)=> {                        
                        n.precalc.label = `Label ${n.mergeId}`
                        n.precalc.label2 = `${n.precalc.layoutWeight}`
                    },
                    // calculates hyperbolic node coordinates.
                    layout: {                        
                        type:               hyt.layouts.layoutBergé,                        
                        // the wegde (see lamping rao 95 for definition) must be 
                        // given by developer
                        rootWedge: {                                        
                            // defines the rotation of the tree
                            // valid values are 0 <= angle < 2π
                            orientation:    0,
                            // valid values are 0 < angle < 2π
                            // a value of π*1.99999 lays out the children of the root node 
                            // on a full circle
                            angle:          π*1.99999     
                        },
                        // defines the layout weight for each node,
                        // this means the function is called for each node.
                        // return the weight for the given node n.
                        // if not specified, sibling will receive the same space 
                        // (wedge angle).
                        // if weight is specified, the angles of sibling wedges will 
                        // be proportional to to the weight of the nodes.
                        weight: (n)=> {                             
                            //if (n.data.productname == "XXX")                            
                            if (n.mergeId == 4) return 16000
                            return 1
                        },
                        
                    },
                    
                    // removes unimportant nodes to achieve scalability for small λ values.
                    // if no type is specified, no node filter is applied.                    
                    filter: {                        
                        maxlabels:          20,  // number of visible labels.                        
                        focusExtension:     2.7, // labels outside of focusExtension*λ are always hidden 
                    },
                    
                    // all rendered objects are placed n a unit disc. 
                    // complex numbers are used to describe points. (x = re, y = im)
                    // polar coordinates are useful in some cases, so check coordinate type 
                    // (Ck = cartesian, Cp = polar)
                    // all units specified in this section are relative to the unit disk.
                    // i.e. a node radius of .1 means the node has a radius of 10% of the unit disc diameter.
                    geometry: {
                        // is used to configure layers, including the layer visibility,
                        // and therefore also used to hide/show layers 
                        layerOptions:       {
                            'stem-arc':    { invisible: true, hideOnDrag: true },
                            'cells':       { invisible: true, hideOnDrag: true },
                            'λ':           { invisible: true, hideOnDrag: true },
                            'center-node': { invisible: false, hideOnDrag: false },
                            'images':      { width: .1, height: .1 },
                            'link-arcs':   { 
                                stroke: n=> { // proposed
                                    if (n.mergeId == 12) return 'orange'
                                    return undefined
                                },                                  
                                // is called for each node when shown
                                // return the width of the edge for the given node n.
                                strokeWidth: arcWidth,  
                                // valid values are:
                                // '+': hyperbolic arc
                                // '-': inverse hyperbolic arc 
                                // 'l': straight line
                                linkCurvature:      'l',                  
                            }, 
                            'nodes':   { 
                                // is called for each node when shown
                                // return the color for given node n
                                fill: n=> { // proposed                                    
                                    if (n.mergeId == 12) return 'yellow'
                                    if (!n.children) return 'red'
                                    return '#a5d6a7'
                                },  
                                stroke:  n=> { // proposed                                    
                                    if (n.mergeId == 12) return 'orange'                                    
                                    return 'white'
                                },  
                                strokeWidth: n=> .005
                            },
                            'labels': {                                
                                delta: (d, i, v)=> 
                                {
                                    //return { re:0, im:.05 }
                                    return hyt.CaddC(
                                        hyt.CptoCk({ 
                                            θ: d.cachep.θ, 
                                            r: .025 * d.distScale * 1.5 
                                        }),
                                        hyt.CaddC(
                                            hyt.bboxOval(d, 'labelslen'),
                                            { re:0, im:-.02*d.distScale }
                                        )
                                    )
                                },                                
                                // for label layout the bounding box of labels must be calculated.
                                // captionFont is used for this calculations. 
                                // is must be the same font size as used for labels. 
                                // unfortunately reading the css font size does not work.                        
                                captionFont: '6.5px Roboto',                               
                                
                                //captionHeight: 

                                background: n=> true
                            },
                            'labels2': {
                                invisible: false, 
                                hideOnDrag: false,
                                text:  (d)=> d.precalc.label2, 
                                color: d=> (d.mergeId == 12?'red':undefined),
                                captionFont: '6.5px Roboto',
                                labelHeight: 0.2,
                                delta: (d, i, v)=> 
                                {
                                    const specialv = { θ: d.cachep.θ, r: .025 * d.distScale * 1.5 }
                                    const specialvCk = hyt.CptoCk(specialv)

                                    const bbo = hyt.bboxOval(d, 'labels2len')
                                    const twolinetrick = { re:-.0015, im:.02*d.distScale }
                                    const staticOffset = hyt.CaddC(bbo, twolinetrick)
                                    return hyt.CaddC(specialvCk, staticOffset)
                                }
                            }
                        },     
                        
                        captionHeight: 0.1,
                        // this function can be used to prefilter nodes.                        
                        // it is called for each frame, 
                        // therefore a fast implementn=> .5mportant.
                        // if the prefilter is the san=> .5h frame, 
                        // please consider to filter n=> .5aloader function.
                        nodeFilter:         n=> true,
                        // is called for each node on node creation
                        // return the radius for the given node n.                        
                        nodeRadius: (ud, n) => {  
                            //if (n.data.price < 20) return 0
                            if (n.mergeId == 1) return 0
                            if (n.mergeId == 2) return .025
                            if (n.mergeId == 3) return .033
                            if (n.mergeId == 12) return .13
                            return .025
                        },
                                                
                        // is called for each visible node for each frame.
                        // this factor in interval (0, 1) is applied to the nodeRadius                        
                        nodeScale:          n=> .4, //nodeScale,       
                        //nodeScale:          n=> nodeScale,                       
                    },
                    interaction: {
                        // the node click area is the voronoi cell in euclidean space.
                        // this way, wherever the user clicks, a node can be associated
                        // n: clicked node
                        // m: click coordinates
                        // l: event source layer
                        onNodeClick: (n, m, l)=> { 
                            console.log('### EVENT: onNodeClick', n.mergeId, n)
                            ht.api.goto({ re:-n.layout.z.re, im:-n.layout.z.im }, null)
                                .then(()=> l.view.hypertree.drawDetailFrame())                            
                        },
                        // is called when center node changes.
                        // the new center node is given by n
                        onCenterNodeChange: n=> {
                            console.log('### EVENT: onCenterNodeChange', n.mergeId, n)
                            //hypertree2.loadfile(customerX)
                            //hypertree2.gotoProduct(Y)
                        },
                        // defines minimum and maximum link length
                        // default mouse wheel behavior is to change λ 
                        λbounds: [ .25, .5 ],
                        // mouse wheel speed
                        wheelFactor: 1.175,
                    }
                }
            )
            var animationNode1 = ht.data.children[1]
            var animationNode2 = ht.data.children[1].children[1]
            var animationNode3 = ht.data.children[1].children[1]
            var animationNode4 = ht.data.children[1].children[1].children[0]
            
            // after the component is created, 
            // init promise can be used to set additional actions.
            // since those are typically non blocking operations like
            // animations, javascript promises are used.
            ht.initPromise
                .then(()=> new Promise((ok, err)=> ht.animateUp(ok, err)))
                //.then(()=> ht.api.gotoNode(animationNode1))
                .then(()=> ht.api.gotoNode(animationNode2))
                //.then(()=> ht.api.gotoNode(animationNode3))
                //.then(()=> ht.api.gotoNode(animationNode4))
                .then(()=> ht.api.gotoHome())
                .then(()=> ht.api.gotoλ(.25))
                .then(()=> ht.api.gotoλ(.5))
                .then(()=> ht.api.gotoλ(.4))
                .then(()=> ht.drawDetailFrame())
        </script>
    </body>
</html>


